# -*- coding: utf-8 -*-
"""
/***************************************************************************
                                 A QGIS WFS plugin

 This plugin connect to WPS via OWSLib.

 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2020-08-04
        git sha              : $Format:%H$
        copyright            : (C) 2020 by OpenGeoLabs
        email                : info@opengeolabs.cz
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic
from qgis.core import *
from qgis.PyQt.QtGui import *
from qgis.PyQt.QtCore import *
from qgis.PyQt.QtWidgets import *
from qgis.gui import *

from .ui_settings import Ui_Settings

import json, webbrowser

from .connect import *

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
WIDGET_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'world_from_space_widget_base.ui'))


class WorldFromSpaceWidget(QDockWidget, WIDGET_CLASS):
    def __init__(self, iface, parent=None):
        """Constructor."""
        super(WorldFromSpaceWidget, self).__init__(parent)

        # TODO put into plugin settings
        # Paths
        self.url_polygons = 'https://api-dynacrop.worldfromspace.cz/api/v2/polygons'
        self.url_processing_request = 'https://api-dynacrop.worldfromspace.cz/api/v2/processing_request'
        self.url_layers = 'https://api-dynacrop.worldfromspace.cz/api/v2/available_layers'
        self.iface = iface
        self.pluginPath = os.path.dirname(__file__)
        self.settingsPath = self.pluginPath + "/../../../qgis_world_from_space_settings"
        QDockWidget.__init__(self, None)

        # Dialogs
        self.setupUi(self)
        self.settingsdlg = Ui_Settings(self.pluginPath, self)

        # Settings
        self.settings = {}
        # print("LOADING SETTINGS")
        self.loadSettings()

        # Buttons
        self.pushButtonSettings.setIcon(QIcon(os.path.join(os.path.dirname(__file__), "icons/settings.png")))
        self.pushButtonSettings.clicked.connect(self.showSettings)
        self.pushButtonSave.setIcon(QIcon(os.path.join(os.path.dirname(__file__), "icons/save.png")))
        self.pushButtonSave.clicked.connect(self.saveRasters)
        self.pushButtonHelp.setIcon(QIcon(os.path.join(os.path.dirname(__file__), "icons/help.png")))
        self.pushButtonHelp.clicked.connect(self.showHelp)
        self.pushButtonGetIndex.clicked.connect(self.createPolygons)
        self.pushButtonCancel.clicked.connect(self.cancelRequest)

        # Global variables
        self.polygons = []
        self.requests = []
        self.loadPolygons()
        self.loadTypesList()
        self.polygons_to_process = []
        self.polygons_to_register = []
        self.current_polygon_to_register_id = 0
        self.requests_to_register = []
        self.current_request_to_register_id = 0
        self.number_of_polygons_to_process = 0

        self.setDefaults()

    def setDefaults(self):
        now = QDateTime.currentDateTime()
        self.mDateTimeEditStart.setDateTime(now.addDays(-1))

    def showHelp(self):
        try:
            webbrowser.get().open(
                "https://github.com/OpenGeoLabs/qgis-world-from-space-plugin/wiki")
        except (webbrowser.Error):
            self.iface.messageBar().pushMessage(QApplication.translate("World from Space", "Error", None), QApplication.translate("World from Space", "Can not find web browser to open help", None), level=Qgis.Critical)

    def get_form_of_output(self, index):
        """
        Returns parameter for API according to the selected items from the list.
        :param index:
        :return:
        """
        if index == 0:
            return "observation"
        if index == 1:
            return "field_zonation"
        if index == 2:
            return "time_series"

    def loadSettings(self):
        """
        Loads the settings from the file.
        :return:
        """
        if os.path.exists(self.settingsPath + "/settings.json"):
            with open(self.settingsPath + "/settings.json") as json_file:
                self.settings = json.load(json_file)
                self.loadIndexesList()

    def showSettings(self):
        """
        Opens the dialog for the settings.
        :return:
        """
        # First we loads the settings from the file.
        self.settingsdlg.updateSettings()
        self.settingsdlg.show()

    def loadIndexesList(self):
        """
        Loads list of indexes.
        :return:
        """
        self.getIndexes()

    def getIndexes(self):
        self.loadindexes = Connect()
        self.loadindexes.setType('GET')
        self.loadindexes.setUrl(self.url_layers + "?api_key=" + self.settings['apikey'])
        self.loadindexes.statusChanged.connect(self.onLoadIndexesResponse)
        self.loadindexes.start()

    def onLoadIndexesResponse(self, response):
        """
        Loads list of indexes.
        :return:
        """
        if response.status in (200, 201):
            data = response.data.read().decode('utf-8')
            response_json = json.loads(data)
            if "log_level" in self.settings and self.settings["log_level"] == 'ALL':
                QgsMessageLog.logMessage("onLoadIndexesResponse " + data, "DynaCrop")
            # indexes = ["NDVI", "EVI", "NDWI", "NDMI", "LAI", "fAPAR", "CWC", "CCC","SMI"]
            self.comboBoxIndexes.clear()
            for index in response_json:
                self.comboBoxIndexes.addItem(index)
            self.pushButtonGetIndex.setEnabled(True)
        else:
            QMessageBox.information(None, QApplication.translate("World from Space", "Error", None),
                                    QApplication.translate("World from Space", "Can not load layers. Check if you set the API key.", None))

    def loadTypesList(self):
        """
        Loads the list of options in human readable form.
        :return:
        """
        types = ["Observation", "Field zonation", "Time series"]
        for type in types:
            self.comboBoxTypes.addItem(type)

    def loadPolygons(self):
        """
        Loads locally stored polygons from previous sessions.
        :return:
        """
        path = self.settingsPath + "/registered_polygons.gpkg|layername=registered_polygons"
        # print(path)
        self.registered_polygons = QgsVectorLayer(path, "Registered polygons", "ogr")

    def polygonIsRegistered(self, polygon):
        """
        Checks if the polygons is already registerd in the DynaCrop system.
        :param polygon: input polygon
        :return: Id if we have its id in local storage None if not.
        """
        if self.registered_polygons.isValid():
            # print("GETTING REGISTERED")
            provider = self.registered_polygons.dataProvider()
            features = provider.getFeatures()
            # print(features)
            for feature in features:
                # print("COMPARE:")
                registered_geometry = feature.geometry()
                # print(registered_geometry)
                # print(polygon)
                if registered_geometry.equals(polygon):
                    # print("SAME")
                    return feature['polygon_id']
            return None
        else:
            QgsMessageLog.logMessage(self.tr("File for storing registered polygons is not available"), "DynaCrop")
            return None

    def transformToWgs84(self, geom):
        """
        Transforms geometry into EPSG:4326
        :param geom:
        :return:
        """
        source_crs = self.iface.layerTreeView().selectedLayers()[0].crs().authid()
        if source_crs != "EPSG:4326":
            crs_src = QgsCoordinateReferenceSystem(source_crs)
            crs_dest = QgsCoordinateReferenceSystem(4326)
            xform = QgsCoordinateTransform(crs_src, crs_dest, QgsProject.instance())
            geom.transform(xform)
            return geom
        else:
            return geom

    def getSelectedParts(self, geometry):
        """
        Returns one or more geometries.
        If the geometry is multigeometry it splits it into list of sigle geometries.
        :param geometry: geometry to split
        :return: list of geometries, if the geometry is single then the list has just one item
        """
        geometries = []
        if geometry.isMultipart():
            multi_geometry = geometry.asMultiPolygon()
            for single_geom in multi_geometry:
                single_geom_wpsg4326 = self.transformToWgs84(QgsGeometry.fromPolygonXY(single_geom))
                geometries.append(single_geom_wpsg4326)
        else:
            single_geom_wpsg4326 = self.transformToWgs84(geometry)
            geometries.append(single_geom_wpsg4326)
        return geometries

    def savePolygonsJob(self, polid):
        """
        Writes polygon check into the queue
        :param polid: polygon id to check
        :return:
        """
        with open(self.settingsPath + "/requests/polygons/" + str(polid), "w") as f:
            f.write(str(polid))

    def saveProcessingRequest(self):
        """
        Saves request into JSOn to use it from connect thread
        :return:
        """
        number_of_zones = 10
        data = {
            "rendering_type": self.get_form_of_output(self.comboBoxTypes.currentIndex()),
            "polygon_id": 0,
            "date_from": self.mDateTimeEditStart.dateTime().toString("yyyy-MM-dd"),
            "date_to": self.mDateTimeEditEnd.dateTime().toString("yyyy-MM-dd"),
            "layer": self.comboBoxIndexes.currentText(),
            "number_of_zones": number_of_zones,
            "api_key": self.settings['apikey']
        }
        with open(self.settingsPath + "/requests/request.json", "w") as outfile:
            json.dump(data, outfile)

    def createPolygons(self):
        """
        Main function where all starts.
        :return:
        """
        self.progressBar.setValue(0)
        self.polygons_to_process = []
        self.polygons_to_register = []
        self.current_polygon_to_register_id = 0
        selectedLayers = self.iface.layerTreeView().selectedLayers()

        # Check if all inputs are ready
        if len(selectedLayers) != 1:
            QMessageBox.information(None, self.tr("ERROR"), self.tr("You have to select one layer."))
            return
        if selectedLayers[0].type() != QgsMapLayer.VectorLayer:
            QMessageBox.information(None, self.tr("ERROR"), self.tr("You have to select vector layer."))
            return
        layer_source = selectedLayers[0].source()
        features = selectedLayers[0].selectedFeatures()
        if len(features) < 1:
            QMessageBox.information(None, self.tr("ERROR"), self.tr("You have to select at least one feature."))
            return

        # Saves the request into JSOn for further usage
        self.saveProcessingRequest()
        self.pushButtonGetIndex.setEnabled(False)
        # Inform user that something happend
        self.progressBar.setValue(5)

        # Check if the index is SMI
        smi_enabled = False
        if self.comboBoxIndexes.currentText() == 'SMI':
            smi_enabled = True

        # Close plot
        if self.comboBoxTypes.currentIndex() == 2:
            import matplotlib.pyplot as plt
            plt.close('all')

        # Loop all selected geometries
        for feature in features:
            geom = feature.geometry()
            geometries = self.getSelectedParts(geom)
            for single_geometry in geometries:
                stripped_z = QgsGeometry.fromPolygonXY(single_geometry.asPolygon())
                geom_wkt = stripped_z.asWkt()
                polygon = {"layer": layer_source, "fid": feature.id(), "geometry": geom_wkt, "smi_enabled": smi_enabled}
                polid = self.polygonIsRegistered(single_geometry)
                self.number_of_polygons_to_process += 1

                # If the polygon is already registered we just save it
                if polid is not None:
                    self.polygons_to_process.append(str(polid))
                    self.savePolygonsJob(polid)
                else:
                    # If the polygon is not registered we add it into the list and then save into the queue
                    self.polygons_to_register.append(polygon)

        if len(self.polygons_to_register) > 0:
            # If there are polygons to register we register them
            self.createPolygon()

    def cancelRequest(self):
        """
        Allows to remove all jobs from the queues and returns back to the starting position.
        :return:
        """

        directory = os.fsencode(self.settingsPath + "/requests/polygons")
        for file in os.listdir(directory):
            filename = os.fsdecode(file)
            os.remove(self.settingsPath + "/requests/polygons/" + str(filename))

        directory = os.fsencode(self.settingsPath + "/requests/jobs")
        for file in os.listdir(directory):
            filename = os.fsdecode(file)
            os.remove(self.settingsPath + "/requests/jobs/" + str(filename))

        self.progressBar.setValue(0)
        self.pushButtonGetIndex.setEnabled(True)

    def onProgressStatusChanged(self, count):
        """
        This is slot where jobs thread sends ifnormation about the progress
        :param count: number of not processed jobs
        :return:
        """
        # If all is done we return to the first state
        if count == 0:
            self.progressBar.setValue(100)
            self.pushButtonGetIndex.setEnabled(True)
        else:
            # We had used already the 5% so the have just 95% for the rest
            one_request_percent = 95 / self.number_of_polygons_to_process / 2
            self.progressBar.setValue(int(105 - (one_request_percent * count)))

    def createPolygon(self):
        """
        Creates thread that registers the polygon
        :return:
        """
        self.createpolygon = Connect()
        self.createpolygon.setType('POST')
        self.createpolygon.setUrl(self.url_polygons)
        # "POLYGON((16.609153599499933 49.20045317863389,16.61297306513714 49.199219336662225,16.61524757838177 49.19759286157719,16.616577954053156 49.195910244858794,16.61400303339886 49.195265226606885,16.6094540069096 49.197368515988586,16.608381123303644 49.19863044668781,16.609153599499933 49.20045317863389))"
        # "POLYGON ((16.56518693093434536 49.22676219888379023, 16.56425126852759178 49.22444226880676865, 16.56539200762623665 49.22282728985813094, 16.56810927379379095 49.22272475151218174, 16.5683784369518996 49.22462171091217442, 16.56854506176405906 49.22571118083784825, 16.56828871589919672 49.22681346805676128, 16.56767348582352284 49.2272620733202686, 16.56518693093434536 49.22676219888379023))"
        # print(self.polygons_to_register[self.current_polygon_to_register_id]["geometry"])

        data = {
            "geometry": self.polygons_to_register[self.current_polygon_to_register_id]["geometry"],
            "api_key": self.settings['apikey'],
            "max_mean_cloud_cover": 0.1,
            "smi_enabled": self.polygons_to_register[self.current_polygon_to_register_id]["smi_enabled"]
        }
        self.createpolygon.setData(json.dumps(data))
        self.createpolygon.statusChanged.connect(self.onCreatePolygonResponse)
        self.createpolygon.start()

    def onCreatePolygonResponse(self, response):
        """
        If the thrtead registers the polygon we move to the other polygon.
        :param response:
        :return:
        """
        if response.status in (200, 201):
            response_json = json.loads(response.data)
            if "log_level" in self.settings and self.settings["log_level"] == 'ALL':
                QgsMessageLog.logMessage("onCreatePolygonResponse " + response.data, "DynaCrop")
            self.polygons_to_process.append(str(response_json["id"]))
            self.savePolygon(self.current_polygon_to_register_id, response_json["id"])
            self.savePolygonsJob(response_json["id"])
        else:
            QMessageBox.information(None, QApplication.translate("World from Space", "Error", None),
                                    QApplication.translate("World from Space", "Can not register selected polygons. Check if the polygon in single geometry.", None))

        # Move to the another polygon if there is any
        self.current_polygon_to_register_id += 1
        if len(self.polygons_to_register) > self.current_polygon_to_register_id:
            self.createPolygon()

    def savePolygon(self, pos, id):
        """
        Saves the polygon into local GPKG file.
        :param pos: where is the polygon in the list
        :param id: id of the polygon from DynaCrop database
        :return:
        """
        if not self.registered_polygons.isValid():
            QgsMessageLog.logMessage(self.tr("File for storing registered polygons is not available"), "DynaCrop")
        else:
            next_fid = self.registered_polygons.featureCount()
            self.registered_polygons.startEditing()
            fet = QgsFeature()
            fet.setGeometry(QgsGeometry.fromWkt(self.polygons_to_register[pos]["geometry"]))
            fet.setAttributes([next_fid, id])
            self.registered_polygons.addFeature(fet)
            # provider.addFeatures([fet])
            self.registered_polygons.commitChanges()

    def saveRasters(self):
        """
        Saves selected raster layers to the local directory and replaces its original with local.
        :return:
        """
        selectedLayers = self.iface.layerTreeView().selectedLayers()
        if len(selectedLayers) < 1:
            QMessageBox.information(None, self.tr("ERROR"), self.tr("You have to select at least one layer."))
            return
        for layer in selectedLayers:
            if layer.type() != QgsMapLayer.RasterLayer:
                QgsMessageLog.logMessage(self.tr("Selected layer is not raster. Skipping"), "DynaCrop")
            else:
                self.saveRaster(layer)
                if layer.isValid():
                    url = os.path.join(self.settings['layers_directory'], layer.name() + ".tif")
                    layer2 = QgsRasterLayer(url, layer.name(), 'gdal')
                    if layer2.isValid():
                        QgsProject.instance().addMapLayer(layer2)
                        QgsProject.instance().removeMapLayer(layer)

        QMessageBox.information(None, QApplication.translate("World from Space", "Error", None),
                                QApplication.translate("World from Space", "Selected raster layers were saved localy.", None))

    def saveRaster(self, layer):
        """
        Saves one raster to he local directory.
        :param layer:
        :return:
        """
        extent = layer.extent()
        width, height = layer.width(), layer.height()
        renderer = layer.renderer()
        provider = layer.dataProvider()
        # crs = layer.crs().toWkt()
        pipe = QgsRasterPipe()
        pipe.set(provider.clone())
        pipe.set(renderer.clone())
        # pa_name, file_name = os.path.split(fileName)
        # save_raster = os.path.join(save_path, file_name)
        p = os.path.join(self.settings['layers_directory'], layer.name() + ".tif")
        file_writer = QgsRasterFileWriter(p)
        file_writer.writeRaster(pipe,
                            width,
                            height,
                            extent,
                            layer.crs())
